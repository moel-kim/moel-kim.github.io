---
title: "[언어학] Prototype"
date: 2024-09-01
tags:
  - linguistics
draft: false
summary: Prototype에 대해 알아보면서 JS에 대해 다시 알아보자
images:
  - https://upload.wikimedia.org/wikipedia/commons/6/6a/JavaScript-logo.png
layout: PostLayout
---

## 개론

현업에 있다보면 항상 신기하게도, 내가 사용하는 도구의 본질에서 멀어집니다.

본질보다는 누군가가 쌓아놓은 Framework나 Layer 위에서 움직입니다. 이걸 추상화라고도 합니다.

매일 같이 Javascript(이하 JS)를 사용하고 있지만, 일을 하다보면 추상화해놓은 것들을 조합만 해도 대부분의 요구사항을 만들 수 있습니다

따라서 이게 `어떻게 돌아가는지에 대한 것`은 자연스럽게 관심에서 멀어집니`

오늘은 그런 `어떻게 돌아가는지에 대한 것` 중에 하나인 JS Prototype에 대해 알아보고, 독자분들께 영감이 되었으면 하는 바램으로 글을 작성했습니다.

글이 조금 깁니다.
또한 `[자바스크립트는 왜 프로토타입을 선택했을까](https://medium.com/@limsungmook/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EB%8A%94-%EC%99%9C-%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85%EC%9D%84-%EC%84%A0%ED%83%9D%ED%96%88%EC%9D%84%EA%B9%8C-997f985adb42)` 해당 글을 참조했습니다. 
## Prototype

결론은 Prototype은 ’문맥을 존중하는 기술의 구현체‘입니다.

### 왜 Prototype인가

컴퓨터 공학과 학생들이 프로그래밍을 배우면 대부분 C, C++, Python, Java 같은 언어로 입문을 합니다. 저 또한 마찬가지였습니다.

그러다 Javascript 언어를 처음 접하면 가장 생소한게 바로 Prototype입니다.

대부분 `왜 Prototype이라는게 있어요?`라고 하면 `상속을 지원하기 위해서요`라는 답변이 돌아오고, 저 같이 Class 문법에 익숙했던 사람은 그냥 Class 쓰면 되는거 아닌가? 라는 생각이 머리속에 듭니다.

그러나 그때 뿐, Javascript가 Class문법을 지원한다는 사실을 알고 나면 Prototype에 대한 의문은 저 멀리 사라져있습니다.

그런데 Prototype을 차용했기 때문에 Javascript만이 가졌던 특성, 그리고 그런 특성들로 인해 있었던 함수등이 있습니다.

바로 bind, call, apply, hoisting, 그리고 악명높은 this이죠.

왜 JS는 위에 나열한 이상한 특성들을 가지면서도, 굳이 다른 언어들과 다른 Prototype 기반을 선택한걸까요?

### 바라보는 관점 바꾸기 

Class 기반 OOP 언어가 객체를 바라보는 관점을 생각해봅시다.

이런 언어는 서양 철학에 기반하고 있습니다. 바로 `눈앞에 실제로, 구체적으로 존재하는 사물이 있다면 반드시 그것의 본질이 존재한다`는 플라톤의 철학이죠.

우리가 앉는 의자를 예로 들겠습니다. "원목 의자", "바퀴 달린 의자", "하이 체어" 등등. 이런 수많은 의자가 실제로 존재한다면 그 본질에는 "의자"라는 것이 존재한다. `이러한 본질의 세계를 Idea라고 하며`, `현실의 의자는 이런 Idea의 "의자"를 모방한 것` 이라는게 해당 철학의 주장입니다.

이런 사고가 프로그래밍 언어에도 녹아들어 만들어진 언어가 바로 `클래스 기반 객체지향 프로그래밍 언어`입니다.

그래서 본질이 되는 의자(Class, Idea)를 만들고 본질을 상속받아 (원목)의자(Idea + a)가 되고 , 그걸 현실세계에 존재(인스턴스화)하도록 합니다.

#### Classification(분류)

이러한 플라톤의 이데아 이론은 후에 확장되어 `분류(classification)`이란 개념으로 정립되었고 다음과 같이 분류를 정리했습니다

> `개체의 속성이 동일한 경우` 개체 그룹이 같은 범주에 속한다. 범주는 정의와 구별의 합이다

이는 우리가 아는 전통적인 Class 기반 객체 지향 프로그래밍의 아이디어-일반화와 일치하며, 속성은 Class의 Property입니다. Property가 유사한 객체가 있다면 일반화 과정을 통해 클래스로 추상화됩니다.

### Prototype

Prototype은 이런 Classification에 대해 정면으로 반박하여 나온 이론입니다.

철학자 비트겐슈타인은 다음과 같이 말했습니다

>공유 속성의 관점에서 정의하기 어려운 개념이 있다(사실상 올바른 분류란 없다)

게임을 예로 들면서 해당 이야기를 생각해봅시다

> 일반적으로 게임은 승자와 패자가 명확합니다. 하지만 그렇지 않은 게임도 있습니다
>
> - 승리 / 패배? 승자가 없는 게임도 있습니다(ex. ring around a rosy 또는 관점에 따라 승자가 달라질 수 있음)
> - 숙련도 여부? 주사위 위주 게임에는 없습니다

즉 공통 속성(Property)를 정의할 수 없는 것들이 현실세계에는 많습니다. 게임 외에도 예술작품 또한 공통 속성을 정의할 수 없습니다.

>세계에 미리 내재되어서 대상과 언어를 완전히 규정하는 어떤 언어란 존재하지 않는다 — 비트겐슈타인

사실 Class 기반 OOP 언어로 프로그래밍 언어들은 적절한 패턴(SOLID, SRP, 디자인 패턴 등)을 사용하지 않으면, 나중에 상속관계로 인해서 확장가능성이 떨어지는 경우를 많이 봤습니다. 

처음부터 모든 것을 예측하여 완벽한 디자인이 나오지 않는 이상, 오히려 Class 기반으로 만들어진 프로그램은 시간이 지날수록 기능추가에 병목이 점차 커지는 현상을 목격한 경우가 많았습니다.

그런데 시간에 의존성이 있는 이상, 처음부터 완벽한 프로그램이라는게 가능할까요?

이러한 Classification에 대해 철학자 비트겐슈타인은 다음과 같이 말했습니다

>표현은 삶의 흐름 속에서만 의미를 갖는다 — 비트겐슈타인

#### 문맥 따르기

`표현은 삶의 흐름 속에서만 의미를 갖는다`라는 말의 의미는 즉 `진정한 본래의 의미`란 존재하지 않고 `상황과 맥락에 의해서 결정된다`입니다. 

친숙한 예를 들어봅시다

![Ung meaning](https://www.ntdtv.kr/assets/uploads/2021/04/d550b1140d09f9b8fc06175926cd473b.jpg)
한국인이 "응"이라고 대답합니다. "응"이 가지는 문법적 의미는 "긍정"입니다.

하지만 실제로는 맥락(Context)에 따라 의미가 바뀝니다. 

"응"이라고 해도 상황, 어조 등에 따라 부정의 의미가 될 수도 있는 것이죠.

또한 현실 세계에서는 대상을 분류할 때 속성 보다는 [유사성](https://www.slideshare.net/slideshow/cog5-lecppt-chapter08/35160482)을 통해 분류하게 된다고 합니다.

![Family](https://img.freepik.com/premium-vector/family-picture-with-three-people-man-with-woman-two-girls_704913-11875.jpg?semt=ais_hybrid)

위의 그림을 봅시다.

위 그림처럼 가족이 있을 때 이 가족이 모두 공유하는 공통 속성은 없습니다. 어느 정도의 공통적인 특징을 있을 수 있지만 모든 가족 구성원에게 적용되는 공통된 특성은 없을 수 있습니다. 

그렇지만 위의 그림을 보면 우리는 `가족 사진`으로 분류합니다. 이런 분류 방식을 `유사성`에 의한 분류라고 합니다.

이 이론은 Prototype 이론의 근거가 됩니다.


#### Prototype Theory

[자바스크립트는 왜 프로토타입을 선택했을까](https://medium.com/@limsungmook/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EB%8A%94-%EC%99%9C-%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85%EC%9D%84-%EC%84%A0%ED%83%9D%ED%96%88%EC%9D%84%EA%B9%8C-997f985adb42)의 말을 그대로 인용하겠습니다.

> “인간은 ‘등급이 매겨진 (개념) 구조(graded structure)’를 가진다”라고 주장합니다. 인간은 사물을 분류할 때 자연스럽게 가장 유사성 높은 것 순서대로 등급을 매긴다는 의미로 볼 수 있습니다. 이렇게 분류했을 때 가장 높은 등급을 가진 녀석이 나올 텐데요, 이것이 바로 원형(Prototype)이다. 란 주장이 프로토타입 이론입니다.

![bird](https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ThdtLo8MUCQ2bcfII6AJcQ.png)


>‘타조'는 전통적인 분류에선 같은 새가 되지만 프로토타입 이론에서는 ‘원형'에서 가장 멀리 떨어진, 즉 ‘비전형적인' 녀석이 됩니다. 범주의 가장 끄트머리에 있는 녀석이 되는 거죠.

> 즉, 객체는 ‘정의’로부터 분류되는 것이 아니라 가장 좋은 보기(prototype, exemplar)로부터 범주화된다고 합니다.

>같은 단어라 할지라도 누가 어떤 상황(context)에서 접했나에 따라 의미가 달라진다는 것입니다. (의미사용이론)

> 예를 들면 아이가 생각하는 새의 범주에서 ‘참새’는 명확하게 새에 속하지만 ‘펭귄' 은 해당 범주에 속하지 못할 수도 있습니다. 아이가 생각할 땐 펭귄이 매우 비전형적이기 때문이죠. 하지만 조류학자가 생각할 때 ‘참새'와 ‘펭귄'은 명확하게 유사한 새의 범주에 속할 수 있습니다. 같은 단어여도 어떤 상황(누가, 어디서…)에서 접했나에 따라 범주는 크게 달라집니다.

즉 정리하자면 다음과 같습니다

- 현실에 존재하는 것 중 가장 좋은 본보기를 원형(prototype)으로 선택한다.
- 문맥(컨텍스트)에 따라 ‘범주’, 즉 ‘의미’가 달라진다.

## So.. Prototype is

이런 이론에 입각하여 태어난 Self언어와 가족유사성을 언어 차원에서 구현한 언어들에 영감을 받은 언어가 Javascript입니다.

Prototype 기반의 OOP 언어의 특징은 다음과 같습니다

- Instance 수준에서 메소드와 변수를 추가할 수 있다
- 객체 생성은 일반적으로 복사를 통해 이루어짐
- 확장(extends)은 클래스가 아닌 위임(delegation)
	- 현재 객체가 메세지에 반응하지 못할 때, 다른 객체로 메세지를 전달하여 상속의 본질을 지원
- 개별 객체 수준에서 객체를 수정하고 발전시키는 능력은 **선험적 분류의 필요성을 줄이고 반복적인 프로그래밍 및 디자인 스타일**을 장려
- Classification 하지 않고 Similarity를 활용하도록 함
- 설계는 맥락에 의해 평가



### 프로그래밍의 본질

결국 프로그래밍이란 글쓰기 입니다.

우리가 회사에서 일을 하는 이유는 사회에 안에서 가치를 만들어내기 위함입니다.

그리고 프로그래머인 저는, 가치를 만들어내기 위해 프로그래밍을 통해 컴퓨터가 해석할 수 있는 코드를 적습니다.

그 코드는 특정 집단이 만들어낸 프로토콜, 소위 `프로그래밍 언어`라는 프로토콜에 맞게 글을 쓰는 것 입니다.

우리가 아는 가장 대중적인 소설책들을 예를 들어보면 다음과 같습니다.

해리포터 시리즈, 반지의 제왕 시리즈.

두 책 모두 훌륭하지만,  그 안에서 쳅터 구성, 문맥 배치, 어체 등은 아예 다릅니다. 하지만 둘 다 훌륭한 책이라고 느낍니다

`뜯어보면 정말 다른 책인데, 왜 둘 다 좋은 책이라고 느낄까?`  라고 질문한다면 저는 이렇게 답변할 것 같습니다

글의 ~~~




## Extra mile - Rescript

오늘 이 글을 쓰게 된 이유는 Flow와 Typescript(이하 TS)를 비교하다가 문득 Javascript 자체에 의문이 들어서 쓰게되었습니다.

제 첫 회사는 Ocaml 기반의 BuckleScript(지금은 Recript로 리브렌딩)를 Frontend 언어로 사용하던 회사였습니다. 구조조정으로 인해 3개월만에 나오긴 했지만 제 프로그래밍 실력에 가장 큰 영향을 줬던 회사였습니다.

그 때 사용했던 BuckleScript라는 언어가 가진 철학, 패러다임, 함수 등이 제게 큰 영감을 주었고, 그런 영감이 저를 어떤 방향으로 이끌었거든요.

하지만 항상 이런 의문이 있었습니다. `왜 BuckleScript 같은 마이너 언어를 선택하게 되었을까?`. 회사라는게 우선 돈을 벌어야하기 때문에 메인스트림에서 아예 벗어나는게 불가능하거든요.

그 이유를 Flow와 TS의 역사를 알아보면서 깨닫게 되었습니다.

알아보기에 앞서 우선, Flow는 Facebook이 TS는 Microsoft에서 만든 JS타입 추론기(혹은 시뮬레이터) 입니다. 비슷해보이지만 두 추론기는 지향하는바가 다릅니다.

TS는 AST를, Flow는 Graph를 사용합니다. 좀 더 간단히 이야기하자면, Typescript는 타입을 즉시 결정하고, Flow는 타입 결정을 추론하여 결정합니다.(그래서 Flow는 타입 정보를 TS에 비해 덜 적어도 됩니다)

[Flow](https://github.com/facebook/flow)의 경우 Ocaml 언어를 통해 Javascript Code Parsing and Analyze 로직이 짜여져있습니다. Ocaml의 힌들리 밀러 타입 시스템이 Flow의 타입 결정 로직과 일치하기 때문에 매우 똑똑한 결정이었을 것 입니다. 

하지만 JS는 Ocaml과 달리 함수형 패러다임에 입각한 언어가 아니기 때문에 타입 추론 버그에 시달릴 수 밖에 없었습니다. 객체에 대한 mutable한 접근을 시뮬레이팅 하거나, JS의 특정한 문법을 Flow의 Graph 전파 로직 내에서 예외처리하기 어려웠겠죠. 

또한 점진적 Migration 측면에서 Typescript가 더 훌륭했기 때문에 점차 시장에서 밀렸을 것 입니다.

그렇지만 Flow가 가진 매력적인 요소들이 많았기에, 이런 요소들을 실제 개발에 도입할 수 있는 환경(Buckle Script or Rescript)을 구축하려고 노력했고, 그 노력이 그린랩스라는 회사의 탄생으로 이어진게 아닌가 싶었습니다.

더 자세한건 `[Flow와 Typescript의 채택](https://blog.rhostem.com/posts/2017-06-11-adopting-flow-and-typescript)` 글을 참고해주세요

그래서 정리하면 이렇습니다
1. Flow는 페이스북이 만들었고 Ocaml 언어로 만들어졌다
	1. React 또한 Ocaml로 프로토타이핑 되었던 시절이 있다
2. BuckleScript는 사실상 Ocaml을 기반으로한 Readable Javascript Converter이다
3. Flow는 Javascript 언어의 한계로 버그 및 이슈가 많다

`따라서 BuckleScript를 기반으로 Flow의 장점을 차용해서 Javascript 개발을 하자`와 같이 된게 아닌가 싶었습니다.

정확하진 않겠지만 Flow를 분석하다 보니 예전부터 의문으로 생각하던게 하나 해결된 것 같아 후련합니다.

## Inspired By

- [adopting-flow-and-typescript](https://jamie.build/adopting-flow-and-typescript.html)
- [자바스크립트는 왜 프로토타입을 선택했을까](https://medium.com/@limsungmook/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EB%8A%94-%EC%99%9C-%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85%EC%9D%84-%EC%84%A0%ED%83%9D%ED%96%88%EC%9D%84%EA%B9%8C-997f985adb42)
* [The Better Parts](https://www.youtube.com/watch?v=PSGEjv3Tqo0&t=300s)


긴 글 읽어주셔서 감사합니다.