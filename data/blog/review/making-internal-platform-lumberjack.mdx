---
title: "[WIP][후기][FEops] 내부 로컬 배포 플랫폼 럼버잭 제작기"
date: 2024-09-01
tags:
  - review
draft: false
summary: 내부 로컬 배포 플랫폼 럼버잭을 제작하면 했던 고민들을 공유합니다
images:
  - https://orangematter.solarwinds.com/wp-content/uploads/2022/03/devops-lifecycle.png
layout: PostLayout
---

<TOCInline toc={props.toc} exclude={'Intro'} asDisclosure />

## 개론

내부 코어로직을 로컬 머신에서 배포 및 테스트 할 수 있는 데스크탑 앱 기반 플랫폼을 만들었습니다.

프레임워크의 동작원리 보다는 프로젝트를 진행하면서 겪었던 문제점들에 대해 소개합니다.

## 프로젝트의 목적

해당 프로젝트의 목적은 `의사소통 비용을 줄인다`입니다.

내부 코어 로직 서비스를 비 Backend 개발자가 실행시키는 것은 대체로 고통스럽습니다.

대략 다음과 같은 과정을 거쳐야하기 때문입니다.

1. Project를 Clone한다
2. Dependency를 설치한다
3. Docker가 필요시 Docker를 설치한다
4. Env를 세팅한다
5. Project를 실행한다

또한 프로젝트 특성상 Windows 환경에서도 실행이 가능해야합니다.

위의 과정이 적어놓은 것에 비해 훨씬 복잡했기 때문에 이를 해결할 내부 SaaS가 필요합니다.

### 기존 개발 프로세스

따라서 내부적으로 Vercel과 같은 Cloud Platform(이하 CP라고 하겠습니다)을 제작하여 사용하고 있었고

다음과 같은 프로세스로 개발이 이루어졌습니다

1. CP에서 배포할 서비스를 선택한다
2. 배포할 서비스가 K8S Pod에 배포될 때 까지 기다린다
3. 배포 후, 각자의 서비스(iOS, Android, Client)에 reverse proxy port에 연결하여 개발한다

하지만 다음과 같은 불편함이 있었습니다.

1. 배포하는데 반영까지 최소 20분 이상 소요는 점
	1. Binary Build와 상관없는 간단한 Config Map 수정임에도 Minimum Time이 소요된다
		1. Core 서비스의 사용자인 Client 개발자에게는 Config Map수정이 주된 변경이다
	2. 변경이 이루어진건지 확인하기 어렵다
2. 필요없는 Core Service도 함께 배포되기 때문에 Pod의 용량이 크다

###  해결책

따라서 위의 문제를 해결하기 위해, 팀 내부적으로 논의된 해결책은 다음과 같았습니다

* Core Service들을 로컬 머신에 띄울 수 있는 Local Deploy Platform을 만든다
- Cross-platform(Windows, Mac)을 지원한다
	- QA Engineer, Mobile Native Engineer를 위해
- Docker Free를 지향하고, Core Service가 사용하는 third-party service는 직접 build 후 Local Deploy Platform이 내장한다.

위의 논의를 바탕으로 DRI를 가지고 Local Deploy Platform인 Lumberjack을 제작했습니다.

## 고민사항

`개발 시간 단축`, `리서치 과정에서 될지 않될지 판단을 빠르게` 하는게 가장 큰 숙제였습니다.

또한 팀 내에 개발 리소스가 부족했기 때문에, 우선 의사소통 비용 최적화 및 확장 가능성을 위주 고민했습니다.

위의 고민을 토대로 세운 원칙과 의사결정 사항은 다음과 같습니다.

- 비 Frontend 개발자도 쉽게 유지보수가 가능할 것
	- Copy & Paste로 개발이 되도록 설계한다
		- Type Extraction Utility 제작
		- API 정의, 구현, 사용처의 폴더구조를 통일화
		- AI 기반 UI를 만들어주는 UI System을 사용
	- 패턴, 구조 등의 문서화를 자동화 한다
		- Docusaurus와 같은 문서 자동화 도구를 도입
- Frontend와 Backend 개발자간의 의사소통 비용을 최적화한다
	- GraphQL codegen과 같은 API Schema 기반으로 시스템적으로 의사소통
		- 단, 유지보수 문제로 GraphQL은 사용하지 말 것
	- Frontend와 Backend 빌드 프로세스를 분리할 것
	- Format & Build 자동화
		- 핵심적인 내용만 코드리뷰가 가능하도록 할 것
		- Main branch의 모든 commit은 Build되는 버전이다
- 사람이 놓치기 쉬운 부분은 자동화 한다
	- 앱 Relase는 Github Action & Github Release를 통해 자동화한다
	- 앱이 요구하는 Redis, DynamoDB 등의 바이너리 빌드를 자동화한다


## 기술 스택

위의 고민을 통해 결정한 기술 스택은 다음과 같습니다

* FE
	* React 18.2.0
	* React Query v5
	* React Hook Form
	* Shadn UI
		* [Radix UI](https://www.radix-ui.com)
		* [v0](https://v0.dev)
* BE
	* Nest.js
* API Schema
	* [ts-rest](https://ts-rest.com)
* Common
	* zod
	* husky
* Bundling
	* PNPM
	* Electron-vite
	* Github Release

## 발생했던 문제

프로젝트를 진행하면서 발생한 문제는 다음과 같습니다.

* Monorepo 사용 불가
* 배포 환경별 Folder Permission 
* Binary Build and Crush
* Nestjs Shutdown Hook
* Redis Instance Flush
* Code Sign
* IPC Event 중복 등록
* Build and Release

위의 문제 해결 과정은 아래 의사결정 항목에서 자세히 설명하겠습니다.

## 의사결정

### 잘했던 결정

### Contract 기반 개발 프로세스 도입

기존 개발 프로세스는 다음과 같았습니다

1. Backend 개발자가 API를 제작한다
2. 업데이트된 API Request, Response를 OpenAPI 기반 문서에 업데이트한다
3. 해당 OpenAPI 문서를 이용해서 Client에서 Typegen을 한다
4. Typegen된 API를 기반으로 API Fetching을 한다

해당 방식의 문제점은 다음과 같습니다

1. Backend 개발자가 수기로 OpenAPI에 명시된 API Request, Response를 업데이트 해야한다. 
	1. 휴먼 에러가 발생할 수 있다
2. API Schema가 정의될 때 까지 Frontend 개발자가 상상해서 코딩하고 있어야한다.

위의 병목과 휴먼 에러를 방지하면, 기능 개발을 신속하게 할 수 있을 것이라 생각했습니다

추가적으로 Contract 기반 개발 프로세스를 도입하면서 합의한 내용은 다음과 같습니다

1. REST API 기반으로 통신할 것
2. 개발 이전에 필요한 REST API의 Request, Response를 미리 정의할 것
	1. 단 세부적인 Parameter naming 변경은 Backend 개발자에게 위임한다
	2. Typescript 레벨에서 검사가 되기 때문에, 변경 비용은 감당할 수 있다
3. REST API 설계시 [Resource 단위](https://restfulapi.net/resource-naming/)로 분리하여 제작할 것
4. Schema에 대한 API가 정의되기 전에는, Mock Autogen을 통해 개발 프로세스를 진행할 것

위의 합의를 통해, Frontend와 Backend 개발을 동시에 개발할 수 있는 환경이 조성되었습니다.

또한 Contract를 우선적으로 정의했기 때문에, 더 좋은 API Interface설계에 대해 함께 고민할 수 있게 되어 좋았습니다.

### Copy and Paste Development


현재 속해있는 팀은 Frontend 리소스가 부족합니다.

복사 붙여넣기 개발 환경이 되기 위해 다음과 같은 의사결정을 했습니다.

#### Contract와 API Controller & API Fetching Hook 구조 통일화

해당 프로젝트는 다음과 같은 폴더구조를 가지고 있습니다.





### Make & Skeleton & Render Pattern


### 아쉬운 결정

초기에 Monorepo 형상을 채택했던 점이 가장 큰 아쉬움이었습니다.

또한 Docker Free라는게 너무 무리였지 않나 싶습니다.

Backend Core 로직에 점차 Message Queue Service, 