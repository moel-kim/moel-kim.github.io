---
title: "[WIP][후기][FEops] 내부 로컬 배포 플랫폼 럼버잭 제작기"
date: 2024-09-01
tags:
  - review
draft: false
summary: 내부 로컬 배포 플랫폼 럼버잭을 제작하면 했던 고민들을 공유합니다
images:
  - https://orangematter.solarwinds.com/wp-content/uploads/2022/03/devops-lifecycle.png
layout: PostLayout
---

<TOCInline toc={props.toc} exclude={'Intro'} asDisclosure />

## 개론

내부 코어로직을 로컬 머신에서 배포 및 테스트 할 수 있는 데스크탑 앱 기반 플랫폼을 만들었습니다.

프레임워크의 동작원리 보다는 프로젝트를 진행하면서 겪었던 문제점들에 대해 소개합니다.

## 프로젝트의 목적

해당 프로젝트의 목적은 `의사소통 비용을 줄인다`입니다.

내부 코어 로직 서비스를 비 Backend 개발자가 실행시키는 것은 대체로 고통스럽습니다.

대략 다음과 같은 과정을 거쳐야하기 때문입니다.

1. Project를 Clone한다
2. Dependency를 설치한다
3. Docker가 필요시 Docker를 설치한다
4. Env를 세팅한다
5. Project를 실행한다

또한 프로젝트 특성상 Windows 환경에서도 실행이 가능해야합니다.

위의 과정이 적어놓은 것에 비해 훨씬 복잡했기 때문에 이를 해결할 내부 SaaS가 필요합니다.

### 기존 개발 프로세스

따라서 내부적으로 Vercel과 같은 Cloud Platform(이하 CP라고 하겠습니다)을 제작하여 사용하고 있었고

다음과 같은 프로세스로 개발이 이루어졌습니다

1. CP에서 배포할 서비스를 선택한다
2. 배포할 서비스가 K8S Pod에 배포될 때 까지 기다린다
3. 배포 후, 각자의 서비스(iOS, Android, Client)에 reverse proxy port에 연결하여 개발한다

하지만 다음과 같은 불편함이 있었습니다.

1. 배포하는데 반영까지 최소 20분 이상 소요는 점
	1. Binary Build와 상관없는 간단한 Config Map 수정임에도 Minimum Time이 소요된다
		1. Core 서비스의 사용자인 Client 개발자에게는 Config Map수정이 주된 변경이다
	2. 변경이 이루어진건지 확인하기 어렵다
2. 필요없는 Core Service도 함께 배포되기 때문에 Pod의 용량이 크다

###  해결책

따라서 위의 문제를 해결하기 위해, 팀 내부적으로 논의된 해결책은 다음과 같았습니다

* Core Service들을 로컬 머신에 띄울 수 있는 Local Deploy Platform을 만든다
- Cross-platform(Windows, Mac)을 지원한다
	- QA Engineer, Mobile Native Engineer를 위해
- Docker Free를 지향하고, Core Service가 사용하는 third-party service는 직접 build 후 Local Deploy Platform이 내장한다.

위의 논의를 바탕으로 DRI를 가지고 Local Deploy Platform인 Lumberjack을 제작했습니다.

## 고민사항

`개발 시간 단축`, `리서치 과정에서 될지 않될지 판단을 빠르게` 하는게 가장 큰 숙제였습니다.

또한 팀 내에 개발 리소스가 부족했기 때문에, 우선 의사소통 비용 최적화 및 확장 가능성을 위주 고민했습니다.

위의 고민을 토대로 세운 원칙과 의사결정 사항은 다음과 같습니다.

- 비 Frontend 개발자도 쉽게 유지보수가 가능할 것
	- Copy & Paste로 개발이 되도록 설계한다
		- Type Extraction Utility 제작
		- API 정의, 구현, 사용처의 폴더구조를 통일화
		- AI 기반 UI를 만들어주는 UI System을 사용
	- 패턴, 구조 등의 문서화를 자동화 한다
		- Docusaurus와 같은 문서 자동화 도구를 도입
- Frontend와 Backend 개발자간의 의사소통 비용을 최적화한다
	- GraphQL codegen과 같은 API Schema 기반으로 시스템적으로 의사소통
		- 단, 유지보수 문제로 GraphQL은 사용하지 말 것
	- Frontend와 Backend 빌드 프로세스를 분리할 것
	- Format & Build 자동화
		- 핵심적인 내용만 코드리뷰가 가능하도록 할 것
		- Main branch의 모든 commit은 Build되는 버전이다
- 사람이 놓치기 쉬운 부분은 자동화 한다
	- 앱 Relase는 Github Action & Github Release를 통해 자동화한다
	- 앱이 요구하는 Redis, DynamoDB 등의 바이너리 빌드를 자동화한다


## 기술 스택

위의 고민을 통해 결정한 기술 스택은 다음과 같습니다

* FE
	* React 18.2.0
	* React Query v5
	* React Hook Form
	* Shadn UI
		* [Radix UI](https://www.radix-ui.com)
		* [v0](https://v0.dev)
* BE
	* Nest.js
* API Schema
	* [ts-rest](https://ts-rest.com)
* Common
	* zod
	* husky
* Bundling
	* PNPM
	* Electron-vite
	* Github Release

## 발생했던 문제

프로젝트를 진행하면서 발생한 문제는 다음과 같습니다.

* Monorepo 사용 불가
* 배포 환경별 Folder Permission 
* Binary Build and Crush
* Nestjs Shutdown Hook
* Redis Instance Flush
* Code Sign
* IPC Event 중복 등록
* Build and Release

위의 문제 해결 과정은 아래 의사결정 항목에서 자세히 설명하겠습니다.

## 의사결정

### 잘했던 결정

### Contract 기반 개발 프로세스 도입

기존 개발 프로세스는 다음과 같았습니다

1. Backend 개발자가 API를 제작한다
2. 업데이트된 API Request, Response를 OpenAPI 기반 문서에 업데이트한다
3. 해당 OpenAPI 문서를 이용해서 Client에서 Typegen을 한다
4. Typegen된 API를 기반으로 API Fetching을 한다

해당 방식의 문제점은 다음과 같습니다

1. Backend 개발자가 수기로 OpenAPI에 명시된 API Request, Response를 업데이트 해야한다. 
	1. 휴먼 에러가 발생할 수 있다
2. API Schema가 정의될 때 까지 Frontend 개발자가 상상해서 코딩하고 있어야한다.

위의 병목과 휴먼 에러를 방지하면, 기능 개발을 신속하게 할 수 있을 것이라 생각했습니다

추가적으로 Contract 기반 개발 프로세스를 도입하면서 합의한 내용은 다음과 같습니다

1. REST API 기반으로 통신할 것
2. 개발 이전에 필요한 REST API의 Request, Response를 미리 정의할 것
	1. 단 세부적인 Parameter naming 변경은 Backend 개발자에게 위임한다
	2. Typescript 레벨에서 검사가 되기 때문에, 변경 비용은 감당할 수 있다
3. REST API 설계시 [Resource 단위](https://restfulapi.net/resource-naming/)로 분리하여 제작할 것
4. Schema에 대한 API가 정의되기 전에는, Mock Autogen을 통해 개발 프로세스를 진행할 것

위의 합의를 통해, Frontend와 Backend 개발을 동시에 개발할 수 있는 환경이 조성되었습니다.

또한 Contract를 우선적으로 정의했기 때문에, 더 좋은 API Interface설계에 대해 함께 고민할 수 있게 되어 좋았습니다.

### Copy and Paste Development


현재 속해있는 팀은 Frontend 리소스가 부족합니다.

복사 붙여넣기 개발 환경이 되기 위해 다음과 같은 의사결정을 했습니다.

#### Shadcn UI 및 v0 도입

내부 배포툴 특성상 UI의 중요성 보다는 기능의 완성도가 중요합니다.

또한 Backend 개발자가 내부 배포툴의 기능을 제작할 가능성도 있었습니다.

따라서 UI 자동 생성 도구를 도입하고, UI는 AI에, 로직은 개발자에게 도입하는게 최선이라 생각했습니다.

#### Contract와 API Controller & API Fetching Hook 구조 통일화

해당 프로젝트는 다음과 같은 폴더구조를 가지고 있습니다.

```
src/
├── main        # Electron App Entry Point(Handling renderer app, server app init and close lifecycle)
├── preload     # Electron App Context Bridge` `for` `IPC(Internal Procedure call)
├── renderer    # Electron App Renderer(For now. written in React. It could be replaced to Vue, Svelte, Solid, etc..)
├── server      # Electron App Backend Server(For now. written in Nestjs, Bind to src/main)
└── shared      # Contract(Api Spec Manager) and common utility defined

```


그리고 shared 폴더 안에는 contract(api schema 명세)가 정의되어있습니다

contract
```contract folder structure

shared/
├── contract
        ├── environment     # contract for controlling lumberjack app(app log, app metadata(redis, dynamodb, etc...))
        ├── farms           # contract for deploy farm
        ├── local-builds    # contract for searching downloaded builds(searching downloaded build list)
        ├── remote-builds   # contract for searching remote builds(searching remote branch list, searching remote builds, etc...)
        └── ...define your own contract
└── ...etc

```

그리고 위의 폴더 구조 그대로 Backend API Controller와 Frontend Api Fetching Hook을 그대로 만듭니다

frontend api fetching
```frontend folder structure

renderer/
├── api
        ├── environment
            ├── query-key.ts    # define react-query key for managing caching, invalidation policy
            └── ...define your own React Query Hook base on api call
        ├── farms
            ├── query-key.ts    # define react-query key for managing caching, invalidation policy
            └── ...define your own React Query Hook base on api call
        └── ...define your own React Query Hook

└── pages, hooks, components, lib, config, locales, styles, types, etc...

```

backend controller
```backend folder structure

server/
├── modules
        ├── environment                 # modules.. defined by contract
        ├── farms                       # modules..
        ├── local-builds                # modules..
        ├── remote-builds               # modules..
        └── ...define your own modules`

└── ...some nestjs app entry and configuration files

```

위의 구조를 가지기 전, 다른 프로젝트들이 가졌던 문제는 다음과 같습니다

1. API 정의(Contract)에 대한 명세와 실제 구현이 다른 경우가 지속적으로 발생했다
	1. + API 명세에는 있지만 Backend Controller에는 구현되어 있지 않아도 타입 에러가 발생하지 않았다
2. API로 불러온 데이터가 페이지별로 처리하는 로직이 다른 경우가 있었다.
	1. 같은 API임에도 Caching Hook을 통해 공통화되지 못해 여러번 호출이 되었다.

위의 구조를 통해서 가지는 이점은 다음과 같습니다

1. API Spec을 폴더 구조를 통해 한 눈에 파악이 가능합니다
	1. 또한 해당 구조를 Backend, Frontend 동일하게 가져가기 때문에 사용자의 의도를 파악하기 쉽습니다
2. API 사용 및 Cache & Invalidation에 대한 로직을 설계하기 쉽습니다
	1. 한 API에 대한 정의는 오직 renderer/api에 정의된 API Fetching Hook을 사용하기 떄문입니다.
		1. 다만 예외적인 케이스를 처리하기 위해서, 타입 확장성을 열어놔야합니다.
	2. 추가적으로 Contract에 정의된 내용 + File 구조를 기반으로 `Backend Controller와 Frontend API Fetching Hook을 자동으로 생성가능하도록 자동화`가 가능합니다

따라서 자동화 가능성, 일관성을 통한 의도 파악 시간 단축 등을 이유로 잘했던 결정이라 생각합니다.


### 아쉬운 결정

#### Monorepo 채택 및 제거

초기에 Monorepo 형상을 채택했던 점이 가장 큰 아쉬움이었습니다.

처음에는 

#### Docker Free

또한 Docker Free라는게 너무 무리였지 않나 싶습니다. 이 부분은 프로젝트 초기부터 결정된 사항이었고, 또 필수적인 부분이라 바꿀 수 없었습니다.

럼버잭을 사용하는 사용자의 컴퓨터 대부분에서 가상머신을 사용중입니다.(BlueStack, Android VM)

또 Windows 환경에서는 위의 가상머신과 WSL2 Docker와 함께 사용하면 충돌이 나기 때문에 Docker Free는 필수였습니다.

하지만 Backend Core 로직에 점차 Message Queue Service, RDB 등이 도입되면서 Binary 빌드를 하는데 큰 시간이 소요되었습니다.

특히 Mac이면 모르겠지만, Windows는 바이너리를 만드는게 불가능하거나 Reference가 없는 경우가 종종 있었습니다.

또한 바이너리를 빌드하면, 해당 Binary의 Lifecycle을 분석해서 Nestjs Dynamic Module을 만들어야하는데 이 과정이 고통스러웠습니다.

이 부분을 어떻게 해결해야할지가 다음 과제입니다.



### 후기

솔직히 좀 많이 힘들었습니다.

사실 Fullstack을 할 수는 있었지만, 개인적으로 Frontend가 재밌고 흥미로운 것들이 많아서 Frontend 개발을 하고 있었습니다.

하지만 조직에 처음 들어왔을 때 아젠다가 `조직에 도움이 되면 무엇이든 하겠다. 문제 해결할 수만 있다면 된다`였습니다.

그래서 `개발 시간을 최적화하기 위해 Platform을 제작한다`는 기회가 왔을때, 프로젝트 리드로써 임할 수 있는 기회도 받았습니다.

그렇지만 해당 프로젝트는 Fullstack을 넘어서 Desktop Native Build, Binary(Redis, PostgreSQL, DynamoDB) Build, Codesign 등을 모두 해야했습니다.

그렇다고 개발 리소스를 많이 할당받지도 못했구요.

하지만 